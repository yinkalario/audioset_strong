#!/usr/bin/env python3
"""
Generate segmented negative metadata from raw negative metadata.

This script takes the raw negative metadata files generated by generate_raw_neg_meta.py
and segments them into fixed-length clips (e.g., 1 second) with proper handling of
short segments through concatenation or padding.
"""

import pandas as pd
from typing import List, Tuple
import argparse
from pathlib import Path

# Configuration
seg_clip_length = 1.0  # Length of segmented clips in seconds

# Target sound types to process
target_sound_types = ['baby_cry', 'gun', 'snore']


def load_raw_metadata(file_path: str) -> pd.DataFrame:
    """Load raw metadata TSV file."""
    if not Path(file_path).exists():
        raise FileNotFoundError(f"File not found: {file_path}")

    # Determine the number of columns based on the file
    if 'framed_posneg' in file_path:
        columns = ['segment_id', 'start_time_seconds', 'end_time_seconds', 'label', 'present']
    else:
        columns = ['segment_id', 'start_time_seconds', 'end_time_seconds', 'label']

    df = pd.read_csv(file_path, sep='\t', names=columns, skiprows=1)
    return df


def segment_clip(start_time: float, end_time: float,
                 clip_length: float) -> List[Tuple[float, float]]:
    """
    Segment a single clip into fixed-length segments with corrected logic.

    Args:
        start_time: Start time of the original clip
        end_time: End time of the original clip (never exceeded in output)
        clip_length: Target length for each segment

    Returns:
        List of (start, end) tuples for each segment
    """
    duration = end_time - start_time
    segments = []

    if duration <= 0:
        return segments

    # Calculate number of full segments
    num_full_segments = int(duration // clip_length)

    # Generate full segments
    for i in range(num_full_segments):
        seg_start = start_time + i * clip_length
        seg_end = min(seg_start + clip_length, end_time)  # Never exceed original end
        segments.append((seg_start, seg_end))

    # Handle remaining partial segment
    if num_full_segments * clip_length < duration:
        remaining_start = start_time + num_full_segments * clip_length
        remaining_end = end_time
        remaining_duration = remaining_end - remaining_start

        if remaining_duration >= 0.5 * clip_length:
            # Keep as is - will be padded during data loading
            segments.append((remaining_start, remaining_end))
        else:
            # Move start time to the left to make it clip_length long
            # Create new segment that ends at original end_time and is clip_length long
            new_start = end_time - clip_length
            # Make sure we don't go before the original start_time
            new_start = max(new_start, start_time)
            segments.append((new_start, end_time))

    return segments


def process_metadata_file(input_file: str, output_file: str, clip_length: float):
    """Process a single metadata file and generate segmented version."""
    print(f"Processing {input_file}")

    # Load data
    df = load_raw_metadata(input_file)

    if df.empty:
        print(f"  No data found in {input_file}")
        return

    # Process each row and generate segments
    segmented_rows = []
    has_present_column = 'present' in df.columns

    for _, row in df.iterrows():
        start_time = row['start_time_seconds']
        end_time = row['end_time_seconds']

        # Generate segments for this clip
        segments = segment_clip(start_time, end_time, clip_length)

        # Create new rows for each segment
        for seg_start, seg_end in segments:
            new_row = {
                'segment_id': row['segment_id'],
                'start_time_seconds': round(seg_start, 3),
                'end_time_seconds': round(seg_end, 3),
                'label': row['label']
            }

            if has_present_column:
                new_row['present'] = row['present']

            segmented_rows.append(new_row)

    if not segmented_rows:
        print(f"  No segments generated for {input_file}")
        return

    # Create output DataFrame
    segmented_df = pd.DataFrame(segmented_rows)

    # Ensure proper column order
    if has_present_column:
        columns = ['segment_id', 'start_time_seconds', 'end_time_seconds', 'label', 'present']
    else:
        columns = ['segment_id', 'start_time_seconds', 'end_time_seconds', 'label']

    segmented_df = segmented_df[columns]

    # Create output directory if it doesn't exist
    Path(output_file).parent.mkdir(parents=True, exist_ok=True)

    # Save with header
    with open(output_file, 'w') as f:
        f.write('\t'.join(columns) + '\n')
        segmented_df.to_csv(f, sep='\t', index=False, header=False)

    print(f"  Generated {len(segmented_rows)} segments -> {output_file}")


def process_sound_type(sound_type: str, meta_dir: str, clip_length: float):
    """Process all negative files for a specific sound type."""
    print(f"\nProcessing {sound_type} negative sounds...")

    # Input directory (raw negative labels)
    input_dir = Path(meta_dir) / sound_type / 'raw' / 'neg_strong'

    # Output directory (segmented negative clips)
    output_dir = Path(meta_dir) / sound_type / f'seg{int(clip_length)}s' / 'neg_strong'

    if not input_dir.exists():
        print(f"  Warning: Input directory not found: {input_dir}")
        return

    # Find all TSV files in the input directory
    input_files = [f.name for f in input_dir.glob('*.tsv')]

    if not input_files:
        print(f"  No TSV files found in {input_dir}")
        return

    # Process each file
    for input_filename in input_files:
        input_path = input_dir / input_filename

        # Keep original filename
        output_filename = input_filename
        output_path = output_dir / output_filename

        # Process the file
        process_metadata_file(str(input_path), str(output_path), clip_length)


def main():
    """Main function to process all sound types."""
    parser = argparse.ArgumentParser(
        description='Generate segmented negative metadata'
    )
    parser.add_argument('--meta-dir', default='meta',
                        help='Meta directory containing sound type folders')
    parser.add_argument('--clip-length', type=float, default=seg_clip_length,
                        help='Length of segmented clips in seconds')
    parser.add_argument('--sound-types', nargs='+', default=target_sound_types,
                        help='Sound types to process')
    args = parser.parse_args()

    print("Generating segmented negative metadata...")
    print(f"Clip length: {args.clip_length} seconds")
    print(f"Sound types: {args.sound_types}")
    print(f"Meta directory: {args.meta_dir}")
    print()

    # Process each sound type
    for sound_type in args.sound_types:
        process_sound_type(sound_type, args.meta_dir, args.clip_length)

    print("\nNegative segmentation complete!")


if __name__ == "__main__":
    main()
